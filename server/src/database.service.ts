import { PrismaClient } from '@prisma/client';

// --- ИНТЕРФЕЙСЫ ОСТАЮТСЯ ДЛЯ СОВМЕСТИМОСТИ С КОНТРОЛЛЕРАМИ ---
export interface School { id: string; name: string; activeScheduleId: string | null; }
export interface Schedule { id: string; name: string; schoolId: string; }
export interface Bell { id: string; time: string; name: string; day: string; enabled: boolean; soundId: string | null; scheduleId: string; bellType: string; breakDuration: number; autoGenerated: boolean; groupId: string | null; }
export interface User { id: string; username: string; passwordHash: string; schoolId: string; role: 'admin' | 'superadmin'; }
export interface Sound { id: string; name: string; url: string; }
export type FullSchedule = Schedule & { bells: Bell[] };
export interface SpecialDay { date: string; school_id: string; type: 'HOLIDAY' | 'OVERRIDE'; override_schedule_id: string | null; }

const prisma = new PrismaClient();

async function getDataForSchool(schoolId: string): Promise<{ schedules: Record<string, FullSchedule>; sounds: Sound[]; activeScheduleId: string | null } | null> {
    const school = await prisma.school.findUnique({
        where: { id: schoolId },
        include: {
            schedules: {
                include: {
                    bells: {
                        orderBy: { time: 'asc' }
                    },
                },
            },
        },
    });
    if (!school) return null;
    const schedules: Record<string, FullSchedule> = {};
    for (const s of school.schedules) {
        schedules[s.id] = { ...s, schoolId: s.schoolId, bells: s.bells.map(b => ({...b, soundId: b.soundId || ''}))};
    }
    const sounds: Sound[] = [{ id: "sound-1", name: "Classic School Bell", url: "/sounds/classic.mp3" }, { id: "sound-2", name: "Soft Chime", url: "/sounds/chime.mp3" }];
    return { schedules, sounds, activeScheduleId: school.activeScheduleId };
}

async function addSchedule(scheduleData: { id: string; name: string; schoolId: string }): Promise<FullSchedule> {
    const newSchedule = await prisma.schedule.create({ data: scheduleData });
    return { ...newSchedule, schoolId: newSchedule.schoolId, bells: [] };
}

async function deleteSchedule(scheduleId: string): Promise<boolean> {
    try { await prisma.schedule.delete({ where: { id: scheduleId } }); return true; } catch (error) { console.error(error); return false; }
}

async function setActiveSchedule(schoolId: string, scheduleId: string): Promise<boolean> {
    const result = await prisma.school.update({ where: { id: schoolId }, data: { activeScheduleId: scheduleId }});
    return !!result;
}

async function addBellToSchedule(bell: Omit<Bell, 'autoGenerated'> & {autoGenerated?: boolean}): Promise<Bell> {
    const newBell = await prisma.bell.create({ data: { ...bell, autoGenerated: bell.autoGenerated || false }});
    return {...newBell, soundId: newBell.soundId || ''};
}

async function updateBell(bellId: string, bellData: Partial<Omit<Bell, 'id' | 'scheduleId' | 'schoolId'>>): Promise<Bell | null> {
    try { const updatedBell = await prisma.bell.update({ where: { id: bellId }, data: bellData }); return updatedBell ? {...updatedBell, soundId: updatedBell.soundId || ''} : null; } catch(error) { return null; }
}

async function deleteBell(bellId: string): Promise<boolean> {
    try { await prisma.bell.delete({ where: { id: bellId } }); return true; } catch (error) { return false; }
}

async function getUserByUsername(username: string): Promise<User | null> {
    const user = await prisma.user.findUnique({ where: { username } });
    return user as User | null;
}

// <<< --- ВОТ НУЖНАЯ ФУНКЦИЯ --- >>>
async function getUserById(id: string): Promise<User | null> {
    const user = await prisma.user.findUnique({ where: { id } });
    return user as User | null;
}

async function createUser(userData: Omit<User, 'id' | 'passwordHash'> & { passwordHash: string }): Promise<User> {
    const newUser = await prisma.user.create({ data: userData });
    return newUser as User;
}

async function getSpecialDaysForSchool(schoolId: string): Promise<SpecialDay[]> {
    const days = await prisma.specialDay.findMany({ where: { schoolId }, orderBy: { date: 'asc' } });
    return days.map(d => ({ ...d, school_id: d.schoolId, override_schedule_id: d.overrideScheduleId, type: d.type as 'HOLIDAY' | 'OVERRIDE' }));
}

async function setSpecialDay(data: SpecialDay): Promise<void> {
    await prisma.specialDay.upsert({
        where: { date_schoolId: { date: data.date, schoolId: data.school_id } },
        update: { type: data.type, overrideScheduleId: data.override_schedule_id },
        create: { date: data.date, schoolId: data.school_id, type: data.type, overrideScheduleId: data.override_schedule_id },
    });
}

async function deleteSpecialDay(schoolId: string, date: string): Promise<boolean> {
    try { await prisma.specialDay.delete({ where: { date_schoolId: { date, schoolId } } }); return true; } catch (error) { return false; }
}

async function getAllSchools(): Promise<Pick<School, 'id' | 'name'>[]> {
    return prisma.school.findMany({ select: { id: true, name: true } });
}

async function getScheduleIdForToday(schoolId: string, dateYYYYMMDD: string): Promise<string | null> {
    const specialDayRule = await prisma.specialDay.findUnique({ where: { date_schoolId: { date: dateYYYYMMDD, schoolId } } });
    if (specialDayRule) { return specialDayRule.type === 'HOLIDAY' ? null : specialDayRule.overrideScheduleId; }
    const school = await prisma.school.findUnique({ where: { id: schoolId }, select: { activeScheduleId: true } });
    return school ? school.activeScheduleId : null;
}

async function getRingingBellsForSchedule(scheduleId: string, time: string, day: string): Promise<Bell[]> {
    const bells = await prisma.bell.findMany({ where: { scheduleId, time, day, enabled: true }});
    return bells.map(b => ({...b, soundId: b.soundId || ''}));
}

async function getUsersBySchool(schoolId: string): Promise<Omit<User, 'passwordHash'>[]> {
    const users = await prisma.user.findMany({ where: { schoolId }, select: { id: true, username: true, role: true, schoolId: true } });
    return users.map(user => ({ ...user, role: user.role as 'admin' | 'superadmin' }));
}

async function deleteUser(id: string): Promise<boolean> {
    try { await prisma.user.delete({ where: { id } }); return true; } catch (error) { return false; }
}

async function createSchool(data: { name: string }): Promise<School> {
    const newSchool = await prisma.school.create({ data });
    return newSchool;
}

async function deleteSchool(id: string): Promise<boolean> {
    try {
        // onDelete: Cascade в схеме Prisma позаботится об удалении всех связанных данных
        await prisma.school.delete({ where: { id } });
        return true;
    } catch (error) {
        return false;
    }
}
// <<< --- ВОТ ОБНОВЛЕННЫЙ ЭКСПОРТ --- >>>
export const dbService = {
    getDataForSchool,
    addSchedule,
    deleteSchedule,
    setActiveSchedule,
    addBellToSchedule,
    updateBell,
    deleteBell,
    getUserByUsername,
    getUserById, // <-- Функция добавлена в экспорт
    createUser,
    getSpecialDaysForSchool,
    setSpecialDay,
    deleteSpecialDay,
    getAllSchools,
    getScheduleIdForToday,
    getRingingBellsForSchedule,
    getUsersBySchool,
    deleteUser,
    createSchool,
    deleteSchool,
};