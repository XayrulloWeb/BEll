import Database from 'better-sqlite3';
import path from 'path';

// --- ИНТЕРФЕЙСЫ ---
export interface School {
    id: string;
    name: string;
    activeScheduleId: string | null;
}
export interface Schedule {
    id: string;
    name: string;
    schoolId: string;
}
export interface Bell {
    id: string;
    time: string;
    name: string;
    day: string;
    enabled: boolean;
    soundId: string;
    scheduleId: string;
    bellType: 'lesson' | 'break';
    breakDuration: number; // minutes, used when bellType === 'break'
    autoGenerated?: number; // 1|0 stored in DB
    groupId?: string; // to link related auto-generated bells
}
export interface User {
    id: string;
    username: string;
    passwordHash: string;
    schoolId: string;
    role: 'admin' | 'superadmin';
}
export interface Sound {
    id: string;
    name: string;
    url: string;
}
export type FullSchedule = Schedule & { bells: Bell[] };
export interface RingingBellInfo {
    bellName: string;
    scheduleName: string;
    schoolId: string;
    schoolName: string;
}

const DB_PATH = path.resolve(process.cwd(), 'school-bells.db');
const db = new Database(DB_PATH);

// --- ИНИЦИАЛИЗАЦИЯ И ФУНКЦИИ ---

function initialize() {
    console.log('[DB Service] Инициализация базы данных...');
    // Включаем внешние ключи для каскадного удаления
    db.pragma('foreign_keys = ON');
    db.exec(`CREATE TABLE IF NOT EXISTS schools ( id TEXT PRIMARY KEY, name TEXT NOT NULL, active_schedule_id TEXT );`);
    db.exec(`CREATE TABLE IF NOT EXISTS schedules ( id TEXT PRIMARY KEY, name TEXT NOT NULL, school_id TEXT NOT NULL, FOREIGN KEY (school_id) REFERENCES schools(id) ON DELETE CASCADE );`);
    db.exec(`CREATE TABLE IF NOT EXISTS bells ( id TEXT PRIMARY KEY, name TEXT NOT NULL, time TEXT NOT NULL, day TEXT NOT NULL, enabled BOOLEAN NOT NULL DEFAULT 1, sound_id TEXT, schedule_id TEXT NOT NULL, bell_type TEXT NOT NULL DEFAULT 'lesson', break_duration INTEGER NOT NULL DEFAULT 0, auto_generated INTEGER NOT NULL DEFAULT 0, group_id TEXT, FOREIGN KEY (schedule_id) REFERENCES schedules(id) ON DELETE CASCADE );`);

    // Миграция: добавить столбцы, если база уже существовала
    const bellColumns = db.prepare(`PRAGMA table_info(bells)`).all() as any[];
    const hasBellType = bellColumns.some(c => c.name === 'bell_type');
    const hasBreakDuration = bellColumns.some(c => c.name === 'break_duration');
    const hasAutoGenerated = bellColumns.some(c => c.name === 'auto_generated');
    const hasGroupId = bellColumns.some(c => c.name === 'group_id');
    if (!hasBellType) {
        db.exec(`ALTER TABLE bells ADD COLUMN bell_type TEXT NOT NULL DEFAULT 'lesson'`);
    }
    if (!hasBreakDuration) {
        db.exec(`ALTER TABLE bells ADD COLUMN break_duration INTEGER NOT NULL DEFAULT 0`);
    }
    if (!hasAutoGenerated) {
        db.exec(`ALTER TABLE bells ADD COLUMN auto_generated INTEGER NOT NULL DEFAULT 0`);
    }
    if (!hasGroupId) {
        db.exec(`ALTER TABLE bells ADD COLUMN group_id TEXT`);
    }
    db.exec(`CREATE TABLE IF NOT EXISTS users ( id TEXT PRIMARY KEY, username TEXT UNIQUE NOT NULL, password_hash TEXT NOT NULL, school_id TEXT NOT NULL, role TEXT NOT NULL CHECK (role IN ('admin', 'superadmin')), FOREIGN KEY (school_id) REFERENCES schools(id) ON DELETE CASCADE );`);
    
    const schoolCheck = db.prepare('SELECT id FROM schools WHERE id = ?').get('school_test_001');
    if (!schoolCheck) {
        console.log('[DB Service] Создаем тестовую школу...');
        db.prepare('INSERT INTO schools (id, name) VALUES (?, ?)').run('school_test_001', 'Тестовая Школа №1');
    }
    
    // Создаем тестового пользователя-администратора
    const userCheck = db.prepare('SELECT id FROM users WHERE username = ?').get('admin');
    if (!userCheck) {
        console.log('[DB Service] Создаем тестового администратора...');
        const bcrypt = require('bcrypt');
        const hashedPassword = bcrypt.hashSync('admin123', 10);
        db.prepare('INSERT INTO users (id, username, password_hash, school_id, role) VALUES (?, ?, ?, ?, ?)')
          .run('user_admin_001', 'admin', hashedPassword, 'school_test_001', 'admin');
    }
    
    console.log('[DB Service] База данных готова к работе.');
}

function getRingingBellsForCurrentTime(time: string, day: string): RingingBellInfo[] {
    const stmt = db.prepare(`
      SELECT b.name as bellName, s.name as scheduleName, sch.id as schoolId, sch.name as schoolName
      FROM bells b
      JOIN schedules s ON b.schedule_id = s.id
      JOIN schools sch ON s.school_id = sch.id
      WHERE b.time = ? AND b.day = ? AND b.enabled = 1 AND s.id = sch.active_schedule_id
  `);
    return stmt.all(time, day) as RingingBellInfo[];
}

function getDataForSchool(schoolId: string): { schedules: Record<string, FullSchedule>; sounds: Sound[]; activeScheduleId: string | null } | null {
    const schoolRow: any = db.prepare('SELECT * FROM schools WHERE id = ?').get(schoolId);
    if (!schoolRow) return null;
    const school: School = {
        id: schoolRow.id,
        name: schoolRow.name,
        activeScheduleId: schoolRow.active_schedule_id ?? null,
    };
    const schedulesRaw = db.prepare('SELECT * FROM schedules WHERE school_id = ?').all(schoolId) as Schedule[];
    const schedules: Record<string, FullSchedule> = {};
    for (const s of schedulesRaw) {
        const bellsRaw = db.prepare('SELECT * FROM bells WHERE schedule_id = ?').all(s.id) as any[];
        const bells: Bell[] = bellsRaw.map(b => ({
            id: b.id,
            time: b.time,
            name: b.name,
            day: b.day,
            enabled: !!b.enabled,
            soundId: b.sound_id,
            scheduleId: b.schedule_id,
            bellType: (b.bell_type ?? 'lesson') as 'lesson' | 'break',
            breakDuration: typeof b.break_duration === 'number' ? b.break_duration : 0,
            autoGenerated: b.auto_generated,
            groupId: b.group_id,
        }));
        schedules[s.id] = { ...s, bells };
    }
    const sounds = [
        { id: "sound-1", name: "Classic School Bell", url: "/sounds/classic.mp3" },
        { id: "sound-2", name: "Soft Chime", url: "/sounds/chime.mp3" }
    ];
    return { schedules, sounds, activeScheduleId: school.activeScheduleId };
}

function addSchedule(scheduleData: { id: string; name: string; schoolId: string }): FullSchedule {
    db.prepare('INSERT INTO schedules (id, name, school_id) VALUES (@id, @name, @schoolId)').run(scheduleData);
    return { ...scheduleData, bells: [] };
}

function deleteSchedule(scheduleId: string): boolean {
    // Сбрасываем active_schedule_id у школ, где он указывает на удаляемое расписание
    db.prepare('UPDATE schools SET active_schedule_id = NULL WHERE active_schedule_id = ?').run(scheduleId);
    const result = db.prepare('DELETE FROM schedules WHERE id = ?').run(scheduleId);
    return result.changes > 0;
}

function setActiveSchedule(schoolId: string, scheduleId: string): boolean {
    const result = db.prepare('UPDATE schools SET active_schedule_id = ? WHERE id = ?').run(scheduleId, schoolId);
    return result.changes > 0;
}

function addBellToSchedule(bell: Bell): Bell {
    const params = {
        id: bell.id,
        name: bell.name,
        time: bell.time,
        day: bell.day,
        enabled: bell.enabled ? 1 : 0,
        soundId: bell.soundId,
        scheduleId: bell.scheduleId,
        bellType: bell.bellType,
        breakDuration: typeof bell.breakDuration === 'number' ? bell.breakDuration : 0,
        autoGenerated: bell.autoGenerated ? 1 : 0,
        groupId: bell.groupId ?? null,
    } as any;
    db.prepare(`INSERT INTO bells (id, name, time, day, enabled, sound_id, schedule_id, bell_type, break_duration, auto_generated, group_id) VALUES (@id, @name, @time, @day, @enabled, @soundId, @scheduleId, @bellType, @breakDuration, @autoGenerated, @groupId)`).run(params);
    return bell;
}

// --- УТИЛИТЫ ВРЕМЕНИ ---
function addMinutesToTime(timeHHmm: string, minutesToAdd: number): string {
    const [h, m] = timeHHmm.split(':').map(Number);
    const base = new Date(2000, 0, 1, h, m, 0, 0);
    base.setMinutes(base.getMinutes() + minutesToAdd);
    const hh = String(base.getHours()).padStart(2, '0');
    const mm = String(base.getMinutes()).padStart(2, '0');
    return `${hh}:${mm}`;
}

function updateBell(bellId: string, bellData: Partial<Omit<Bell, 'id' | 'scheduleId'>>): Bell | null {
    const normalized: any = { ...bellData };
    if (typeof normalized.enabled === 'boolean') {
        normalized.enabled = normalized.enabled ? 1 : 0;
    }
    if (typeof normalized.autoGenerated === 'boolean') {
        normalized.autoGenerated = normalized.autoGenerated ? 1 : 0;
    }
    if (normalized.groupId === undefined) {
        // keep as-is; if explicit null desired, client should send null
    }
    const fields = Object.keys(normalized).map(field => `${field.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`)} = @${field}`).join(', ');
    if (!fields) return db.prepare('SELECT * FROM bells WHERE id = ?').get(bellId) as Bell;
    const stmt = db.prepare(`UPDATE bells SET ${fields} WHERE id = @bellId`);
    const params: any = { ...normalized, bellId };
    const result = stmt.run(params);
    if (result.changes === 0) return null; // Если ничего не обновилось - возвращаем null
    return db.prepare('SELECT * FROM bells WHERE id = ?').get(bellId) as Bell;
}

function deleteBell(bellId: string): boolean {
    const result = db.prepare('DELETE FROM bells WHERE id = ?').run(bellId);
    return result.changes > 0;
}

// --- ФУНКЦИИ ДЛЯ РАБОТЫ С ПОЛЬЗОВАТЕЛЯМИ ---

function getUserByUsername(username: string): User | null {
    const stmt = db.prepare('SELECT * FROM users WHERE username = ?');
    const user = stmt.get(username) as any;
    if (!user) return null;
    
    return {
        id: user.id,
        username: user.username,
        passwordHash: user.password_hash,
        schoolId: user.school_id,
        role: user.role
    };
}

function getUserById(id: string): User | null {
    const stmt = db.prepare('SELECT * FROM users WHERE id = ?');
    const user = stmt.get(id) as any;
    if (!user) return null;
    
    return {
        id: user.id,
        username: user.username,
        passwordHash: user.password_hash,
        schoolId: user.school_id,
        role: user.role
    };
}

function createUser(userData: Omit<User, 'id'> & { id: string }): User {
    const stmt = db.prepare('INSERT INTO users (id, username, password_hash, school_id, role) VALUES (@id, @username, @passwordHash, @schoolId, @role)');
    stmt.run({
        id: userData.id,
        username: userData.username,
        password_hash: userData.passwordHash,
        school_id: userData.schoolId,
        role: userData.role
    });
    return userData as User;
}

function updateUser(id: string, userData: Partial<Omit<User, 'id'>>): User | null {
    const fields = Object.keys(userData).map(field => `${field.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`)} = @${field}`).join(', ');
    if (!fields) return getUserById(id);
    
    const stmt = db.prepare(`UPDATE users SET ${fields} WHERE id = @userId`);
    const params: any = { ...userData, userId: id };
    const result = stmt.run(params);
    
    if (result.changes === 0) return null;
    return getUserById(id);
}

function deleteUser(id: string): boolean {
    const result = db.prepare('DELETE FROM users WHERE id = ?').run(id);
    return result.changes > 0;
}

function getUsersBySchool(schoolId: string): User[] {
    const stmt = db.prepare('SELECT * FROM users WHERE school_id = ?');
    const users = stmt.all(schoolId) as any[];
    return users.map(user => ({
        id: user.id,
        username: user.username,
        passwordHash: user.password_hash,
        schoolId: user.school_id,
        role: user.role
    }));
}

export const dbService = {
    initialize,
    getRingingBellsForCurrentTime,
    getDataForSchool,
    addSchedule,
    deleteSchedule,
    setActiveSchedule,
    addBellToSchedule,
    updateBell,
    deleteBell,
    // User functions
    getUserByUsername,
    getUserById,
    createUser,
    updateUser,
    deleteUser,
    getUsersBySchool,
};