// Файл: src/database.service.ts (ПОЛНАЯ ЗАМЕНА)
import Database from 'better-sqlite3';
import path from 'path';

// --- ИНТЕРФЕЙСЫ ---
export interface School { id: string; name: string; activeScheduleId: string | null; }
export interface Schedule { id: string; name: string; schoolId: string; }
export interface Bell { id: string; time: string; name: string; day: string; enabled: boolean; soundId: string; scheduleId: string; bellType: 'lesson' | 'break'; breakDuration: number; autoGenerated?: number; groupId?: string; }
export interface User { id: string; username: string; passwordHash: string; schoolId: string; role: 'admin' | 'superadmin'; }
export interface Sound { id: string; name: string; url: string; }
export type FullSchedule = Schedule & { bells: Bell[] };
export interface SpecialDay { date: string; school_id: string; type: 'HOLIDAY' | 'OVERRIDE'; override_schedule_id: string | null; }
export interface RingingBellInfo { bellName: string; scheduleName: string; schoolId: string; schoolName: string; }

const DB_PATH = path.resolve(process.cwd(), 'school-bells.db');
const db = new Database(DB_PATH);

function initialize() {
    console.log('[DB Service] Инициализация базы данных...');
    db.pragma('foreign_keys = ON');
    db.exec(`CREATE TABLE IF NOT EXISTS schools ( id TEXT PRIMARY KEY, name TEXT NOT NULL, active_schedule_id TEXT );`);
    db.exec(`CREATE TABLE IF NOT EXISTS schedules ( id TEXT PRIMARY KEY, name TEXT NOT NULL, school_id TEXT NOT NULL, FOREIGN KEY (school_id) REFERENCES schools(id) ON DELETE CASCADE );`);
    db.exec(`CREATE TABLE IF NOT EXISTS bells ( id TEXT PRIMARY KEY, name TEXT NOT NULL, time TEXT NOT NULL, day TEXT NOT NULL, enabled BOOLEAN NOT NULL DEFAULT 1, sound_id TEXT, schedule_id TEXT NOT NULL, bell_type TEXT NOT NULL DEFAULT 'lesson', break_duration INTEGER NOT NULL DEFAULT 0, auto_generated INTEGER NOT NULL DEFAULT 0, group_id TEXT, FOREIGN KEY (schedule_id) REFERENCES schedules(id) ON DELETE CASCADE );`);
    db.exec(`CREATE TABLE IF NOT EXISTS users ( id TEXT PRIMARY KEY, username TEXT UNIQUE NOT NULL, password_hash TEXT NOT NULL, school_id TEXT NOT NULL, role TEXT NOT NULL CHECK (role IN ('admin', 'superadmin')), FOREIGN KEY (school_id) REFERENCES schools(id) ON DELETE CASCADE );`);
    db.exec(`CREATE TABLE IF NOT EXISTS special_days ( date TEXT NOT NULL, school_id TEXT NOT NULL, type TEXT NOT NULL CHECK (type IN ('HOLIDAY', 'OVERRIDE')), override_schedule_id TEXT, PRIMARY KEY (date, school_id), FOREIGN KEY (school_id) REFERENCES schools(id) ON DELETE CASCADE, FOREIGN KEY (override_schedule_id) REFERENCES schedules(id) ON DELETE SET NULL);`);
    const bellColumns = db.prepare(`PRAGMA table_info(bells)`).all() as any[];
    if (!bellColumns.some(c => c.name === 'bell_type')) { db.exec(`ALTER TABLE bells ADD COLUMN bell_type TEXT NOT NULL DEFAULT 'lesson'`); }
    if (!bellColumns.some(c => c.name === 'break_duration')) { db.exec(`ALTER TABLE bells ADD COLUMN break_duration INTEGER NOT NULL DEFAULT 0`); }
    if (!bellColumns.some(c => c.name === 'auto_generated')) { db.exec(`ALTER TABLE bells ADD COLUMN auto_generated INTEGER NOT NULL DEFAULT 0`); }
    if (!bellColumns.some(c => c.name === 'group_id')) { db.exec(`ALTER TABLE bells ADD COLUMN group_id TEXT`); }
    if (!db.prepare('SELECT id FROM schools WHERE id = ?').get('school_test_001')) { db.prepare('INSERT INTO schools (id, name) VALUES (?, ?)').run('school_test_001', 'Тестовая Школа №1'); }
    if (!db.prepare('SELECT id FROM users WHERE username = ?').get('admin')) { const bcrypt = require('bcrypt'); const h = bcrypt.hashSync('admin123', 10); db.prepare('INSERT INTO users (id, username, password_hash, school_id, role) VALUES (?, ?, ?, ?, ?)').run('user_admin_001', 'admin', h, 'school_test_001', 'admin'); }
    console.log('[DB Service] База данных готова к работе.');
}

function getDataForSchool(schoolId: string): { schedules: Record<string, FullSchedule>; sounds: Sound[]; activeScheduleId: string | null } | null {
    const schoolRow: any = db.prepare('SELECT * FROM schools WHERE id = ?').get(schoolId);
    if (!schoolRow) return null;
    const school: School = { id: schoolRow.id, name: schoolRow.name, activeScheduleId: schoolRow.active_schedule_id ?? null };
    const schedulesRaw = db.prepare('SELECT * FROM schedules WHERE school_id = ?').all(schoolId) as Schedule[];
    const schedules: Record<string, FullSchedule> = {};
    for (const s of schedulesRaw) {
        const bellsRaw = db.prepare('SELECT * FROM bells WHERE schedule_id = ?').all(s.id) as any[];
        const bells: Bell[] = bellsRaw.map(b => ({ id: b.id, time: b.time, name: b.name, day: b.day, enabled: !!b.enabled, soundId: b.sound_id, scheduleId: b.schedule_id, bellType: (b.bell_type ?? 'lesson'), breakDuration: b.break_duration ?? 0, autoGenerated: b.auto_generated, groupId: b.group_id }));
        schedules[s.id] = { ...s, bells };
    }
    const sounds = [{ id: "sound-1", name: "Classic School Bell", url: "/sounds/classic.mp3" }, { id: "sound-2", name: "Soft Chime", url: "/sounds/chime.mp3" }];
    return { schedules, sounds, activeScheduleId: school.activeScheduleId };
}

function addSchedule(scheduleData: { id: string; name: string; schoolId: string }): FullSchedule { db.prepare('INSERT INTO schedules (id, name, school_id) VALUES (@id, @name, @schoolId)').run(scheduleData); return { ...scheduleData, bells: [] }; }
function deleteSchedule(scheduleId: string): boolean { db.prepare('UPDATE schools SET active_schedule_id = NULL WHERE active_schedule_id = ?').run(scheduleId); const result = db.prepare('DELETE FROM schedules WHERE id = ?').run(scheduleId); return result.changes > 0; }
function setActiveSchedule(schoolId: string, scheduleId: string): boolean { const result = db.prepare('UPDATE schools SET active_schedule_id = ? WHERE id = ?').run(scheduleId, schoolId); return result.changes > 0; }
function addBellToSchedule(bell: Bell): Bell { const params = { id: bell.id, name: bell.name, time: bell.time, day: bell.day, enabled: bell.enabled ? 1 : 0, soundId: bell.soundId, scheduleId: bell.scheduleId, bellType: bell.bellType, breakDuration: bell.breakDuration ?? 0, autoGenerated: bell.autoGenerated ? 1 : 0, groupId: bell.groupId ?? null }; db.prepare(`INSERT INTO bells (id, name, time, day, enabled, sound_id, schedule_id, bell_type, break_duration, auto_generated, group_id) VALUES (@id, @name, @time, @day, @enabled, @soundId, @scheduleId, @bellType, @breakDuration, @autoGenerated, @groupId)`).run(params); return bell; }
function updateBell(bellId: string, bellData: Partial<Omit<Bell, 'id' | 'scheduleId'>>): Bell | null { const n: any = { ...bellData }; if (typeof n.enabled === 'boolean') n.enabled=n.enabled?1:0; if (typeof n.autoGenerated === 'boolean') n.autoGenerated=n.autoGenerated?1:0; const f = Object.keys(n).map(field => `${field.replace(/[A-Z]/g, l=>`_${l.toLowerCase()}`)} = @${field}`).join(', '); if (!f) return db.prepare('SELECT * FROM bells WHERE id = ?').get(bellId) as Bell; const stmt = db.prepare(`UPDATE bells SET ${f} WHERE id = @bellId`); const result = stmt.run({ ...n, bellId }); if (result.changes === 0) return null; return db.prepare('SELECT * FROM bells WHERE id = ?').get(bellId) as Bell; }
function deleteBell(bellId: string): boolean { const result = db.prepare('DELETE FROM bells WHERE id = ?').run(bellId); return result.changes > 0; }
function getUserByUsername(username: string): User | null { const u:any = db.prepare('SELECT * FROM users WHERE username = ?').get(username); if (!u) return null; return { id: u.id, username: u.username, passwordHash: u.password_hash, schoolId: u.school_id, role: u.role }; }
function getUserById(id: string): User | null { const u:any = db.prepare('SELECT * FROM users WHERE id = ?').get(id); if (!u) return null; return { id: u.id, username: u.username, passwordHash: u.password_hash, schoolId: u.school_id, role: u.role }; }
function createUser(userData: Omit<User, 'id'> & { id: string }): User { db.prepare('INSERT INTO users (id, username, password_hash, school_id, role) VALUES (@id, @username, @passwordHash, @schoolId, @role)').run({ id: userData.id, username: userData.username, password_hash: userData.passwordHash, school_id: userData.schoolId, role: userData.role }); return userData as User; }
function updateUser(id: string, userData: Partial<Omit<User, 'id'>>): User | null { const f=Object.keys(userData).map(field => `${field.replace(/[A-Z]/g,l=>`_${l.toLowerCase()}`)} = @${field}`).join(', '); if (!f) return getUserById(id); const stmt=db.prepare(`UPDATE users SET ${f} WHERE id = @userId`); const result=stmt.run({ ...userData, userId: id }); if (result.changes === 0) return null; return getUserById(id); }
function deleteUser(id: string): boolean { const result = db.prepare('DELETE FROM users WHERE id = ?').run(id); return result.changes > 0; }
function getUsersBySchool(schoolId: string): User[] { const users: any[] = db.prepare('SELECT * FROM users WHERE school_id = ?').all(schoolId); return users.map(u => ({ id: u.id, username: u.username, passwordHash: u.password_hash, schoolId: u.school_id, role: u.role })); }

// --- НОВЫЕ И ОБНОВЛЕННЫЕ ФУНКЦИИ ---
function getAllSchools(): School[] {
    return db.prepare('SELECT id, name FROM schools').all() as School[];
}

function getScheduleIdForToday(schoolId: string, dateYYYYMMDD: string): string | null {
    const specialDayRule: any = db.prepare('SELECT type, override_schedule_id FROM special_days WHERE date = ? AND school_id = ?').get(dateYYYYMMDD, schoolId);
    if (specialDayRule) { return specialDayRule.type === 'HOLIDAY' ? null : specialDayRule.override_schedule_id; }
    const school: any = db.prepare('SELECT active_schedule_id FROM schools WHERE id = ?').get(schoolId);
    return school ? school.active_schedule_id : null;
}

function getRingingBellsForSchedule(scheduleId: string, time: string, day: string): Bell[] {
    const stmt = db.prepare('SELECT id, name, time, day FROM bells WHERE schedule_id = ? AND time = ? AND day = ? AND enabled = 1');
    return stmt.all(scheduleId, time, day) as Bell[];
}

// --- ВОТ КОНКРЕТНЫЕ РЕАЛИЗАЦИИ НЕДОСТАЮЩИХ ФУНКЦИЙ ---
function getSpecialDaysForSchool(schoolId: string): SpecialDay[] {
    return db.prepare('SELECT * FROM special_days WHERE school_id = ? ORDER BY date ASC').all(schoolId) as SpecialDay[];
}

function setSpecialDay(data: SpecialDay): void {
    db.prepare(`INSERT INTO special_days (date, school_id, type, override_schedule_id) VALUES (@date, @school_id, @type, @override_schedule_id) ON CONFLICT(date, school_id) DO UPDATE SET type = excluded.type, override_schedule_id = excluded.override_schedule_id`).run(data);
}

function deleteSpecialDay(schoolId: string, date: string): boolean {
    const result = db.prepare('DELETE FROM special_days WHERE school_id = ? AND date = ?').run(schoolId, date);
    return result.changes > 0;
}


// === ФИНАЛЬНЫЙ, ПОЛНЫЙ И ПРАВИЛЬНЫЙ ЭКСПОРТ ===
export const dbService = {
    // Старые функции
    initialize,
    getDataForSchool,
    addSchedule,
    deleteSchedule,
    setActiveSchedule,
    addBellToSchedule,
    updateBell,
    deleteBell,
    getUserByUsername,
    getUserById,
    createUser,
    updateUser,
    deleteUser,
    getUsersBySchool,
    // Новые и обновленные функции
    getAllSchools,
    getScheduleIdForToday,
    getRingingBellsForSchedule,
    // Добавленные функции для календаря
    getSpecialDaysForSchool,
    setSpecialDay,
    deleteSpecialDay,
};